## 🎯 你的问题：

> 为什么当我们用值接收者实现接口时，**`Car` 和 `*Car` 都拥有这个方法**？

---

## ✅ 回答简洁版：

> 因为 **指针类型 `*T` 的方法集包含 `T` 的所有值接收者方法**，
> 也就是说：**指针类型可以调用值方法，反过来不行。**

---

## 🔍 官方定义（来自 Go 语言规范）：

| 类型 | 拥有哪些方法？                                           |
| ---- | -------------------------------------------------------- |
| `T`  | 只有定义为 `func (t T)` 的方法（值方法）                 |
| `*T` | 拥有 `func (t T)` 和 `func (t *T)` 的方法（值+指针方法） |

---

## 👇 举个例子说明

```go
type Driver interface {
	Drive()
}

type Car struct {
	Name string
}

// 值接收者方法
func (c Car) Drive() {
	fmt.Println(c.Name, "is driving")
}
```

此时，`Car` 实现了 `Drive()`：

```go
var d Driver

c1 := Car{Name: "BMW"}
c2 := &Car{Name: "Tesla"}

d = c1 // ✅ OK：Car 拥有值方法 Drive()
d = c2 // ✅ OK：*Car 也可以调用值方法 Drive()
```

---

## 🤔 为什么 `*Car` 也可以赋值给接口？

因为 `*Car` 的方法集里 **也包含值接收者的方法**！

也就是说，Go 帮你做了这个：

```go
(*c2).Drive() // Go 自动解引用调用值方法
```

这也是 Go 很人性化的地方。

---

## ⚠️ 反过来不行

如果你定义的是：

```go
func (c *Car) Drive() { ... }
```

那么就只有 `*Car` 拥有 `Drive()` 方法，`Car` 本身**没有**。

所以：

```go
var d Driver

c1 := Car{}
d = c1 // ❌ 编译错误
```

因为 `Car` 没有指针方法 `Drive()`。

---

## ✅ 结论口诀

> 🔹 **值方法**：`T` 和 `*T` 都能用
> 🔹 **指针方法**：只有 `*T` 能用

---

## ✅ 实战建议

> 如果你实现接口时只写了值方法（`func (T)`），那么 `T` 和 `*T` 都可以赋值给接口。
> 但如果你写的是指针方法（`func (*T)`），就只能用 `*T` 来赋值给接口。
